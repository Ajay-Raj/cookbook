<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Roller Coaster</title>
</head>
<body>

<script src="js/third-party/threejs/three.min.js"></script>
<script src="js/third-party/threejs/StereoEffect.js"></script>
<script src="js/third-party/threejs/DeviceOrientationControls.js"></script>
<script src="js/DetectScreenSize.js"></script>
<script>

      var renderer = new THREE.WebGLRenderer( { antialias: true } );
      renderer.setClearColor( 0xf0f0ff );
      renderer.setSize( window.innerWidth, window.innerHeight );
      document.body.appendChild( renderer.domElement );

      var effect = new THREE.StereoEffect( renderer );
      effect.separation = 0.2;
      effect.targetDistance = 50;
      effect.setSize( window.innerWidth, window.innerHeight );

      var scene = new THREE.Scene();
      scene.autoUpdate = false;

      var light = new THREE.HemisphereLight( 0xfff0f0, 0x606066 );
      light.position.set( 1, 1, 1 );
      scene.add( light );
      
      var train = new THREE.Object3D();
      scene.add( train );

      var camera = new THREE.PerspectiveCamera( 40, window.innerWidth / window.innerHeight, 1, 5000 );
 //     camera.rotation.y = Math.PI;
      scene.add( camera );
      
      var controls = undefined;
      var hasOrientation = function(evt) {
        if (!evt.alpha) {
          return;
        }
        window.removeEventListener('deviceorientation', hasOrientation, false);
        controls = new THREE.DeviceOrientationControls( camera );
        controls.connect();
      };
      window.addEventListener('deviceorientation', hasOrientation, false);
// ground box

for (var i = 0; i < 50; i++) {
		geometry = new THREE.BoxGeometry( 50, 1000, 20 );
		material = new THREE.MeshNormalMaterial();
		mesh = new THREE.Mesh( geometry, material );
		mesh.position.set( Math.random() * 5000 - 2500 , -10, Math.random() * 5000 - 2500 );
		scene.add( mesh );
} 

      // environment

      var geometry = new THREE.PlaneGeometry( 5000, 5000, 15, 15 );
      geometry.applyMatrix( new THREE.Matrix4().makeRotationX( - Math.PI / 2 ) );
      var material = new THREE.MeshLambertMaterial( { color: 0x407000, shading: THREE.FlatShading } );

      geometry.computeFaceNormals();

      var mesh = new THREE.Mesh( geometry, material );
      scene.add( mesh );

      //
/*
      var PI2 = Math.PI * 2;

      var curve = ( function () {

        var vector = new THREE.Vector3();
        var vector2 = new THREE.Vector3();

        return {

          getPointAt: function ( t ) {

            t = t * PI2;

            var x = Math.sin( t * 3 ) * Math.cos( t * 4 ) * 50;
            var y = Math.cos( t * 8 ) * 4 + Math.cos( t * 17 ) + 5;
            var z = Math.sin( t ) * Math.sin( t * 4 ) * 50;

            return vector.set( x, y, z ).multiplyScalar( 20 );

          },

          getTangentAt: function ( t ) {

            var delta = 0.0001;
            var t1 = Math.max( 0, t - delta );
            var t2 = Math.min( 1, t + delta );

            return vector2.copy( this.getPointAt ( t2 ) ).sub( this.getPointAt( t1 ) ).normalize();

          }

        };

      } )();
      
      var funfairs = [];
      var isFullscreen = false;
*/

      window.addEventListener( 'touchend', function () {

        if ( isFullscreen === false ) {

          document.body.webkitRequestFullscreen();

          isFullscreen = true;

        } else {
        
          document.webkitExitFullscreen();
          
          isFullscreen = false;
        
        }
      
      } );
      
      window.addEventListener( 'resize', function () {

        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();

        effect.setSize( window.innerWidth, window.innerHeight );

      }, false );
      
      //

/*      
      var position = new THREE.Vector3();
      var tangent = new THREE.Vector3();

      var lookAt = new THREE.Vector3();
      
      var velocity = 0;
      var progress = 0;

      var cameraPosition = new THREE.Vector3();
      var cameraPositionOld = new THREE.Vector3();
      var cameraQuaternion = new THREE.Quaternion();
      var cameraScale = new THREE.Vector3();

      var cameraOrientation = new THREE.Vector3();
      var cameraVelocity = new THREE.Vector3();
*/

      var animate = function ( time ) {

        requestAnimationFrame( animate );
/*        
        for ( var i = 0; i < funfairs.length; i ++ ) {

          funfairs[ i ].rotation.y = time * 0.0002;

        }



        train.position.copy( position );

  //      tangent.copy( curve.getTangentAt( progress ) );

        velocity -= tangent.y * 0.0000015;
        velocity = Math.max( velocity, 0.00004 );

 //       train.lookAt( lookAt.copy( position ).add( tangent ) );

        //
*/

        if ( controls !== undefined ) {
          controls.update();
        }
        effect.render( scene, camera );
      };

      requestAnimationFrame( animate );

</script>
</body>
</html>
